# Lista encadeada

# Vetores

- Armazenar um conjunto de elementos
- Ocupa, posi√ß√µes sequenciais na mem√≥ria
    - `int v[100]` ‚Üí v √© um elemento para a 1¬™ posi√ß√£o
    - `v[ i ]` ‚Üí v+1*sizeof int ‚áí O(1)
- Tamanho pr√©-fixado
    - tamanho fixo: `int v[100]`;
    - tamanho vari√°vel ‚Üí `malloc` (aloca√ß√£o din√¢mica de mem√≥ria)
    

heresia ‚Üí **VLA - Variable length array - usa apenas para softwares matem√°ticos**

```c
int n;
scanf(‚Äù%d‚Äù, &n);
int v[n]; // alocar o tamanho do vetor com uma vari√°vel
```

# Listas encadeadas

- E se quisermos inserir ou remover elementos de um vetor, em qualquer posi√ß√£o?
- Qual o custo?

Ex: 

```c

int remove (int*v. int i){//recebo o vetor e o elemento q quero remover
	int elem = v[i]; //deslocar todos os elementos do vetor para a esqueda
	for (int j=i;j<n-1;j++) v[i]=v[i+1];
	return element
}

**Complexidade O(n)**
```

<aside>
üí° Conclu√≠do:

1. Vetores s√£o estruturas de acesso r√°pido ‚Üí Custa O(1)
2. Vetores n√£o s√£o boas estruturas para manipula√ß√£o massiva de dados ‚Üí √© chato pq acaba mexendo com todos os elementos ao remover  e inserir um elemento
</aside>

- Uma lista encadeada √© um conjunto de elementos independentes interligados entre si.

- Ponteiro apontando para o pr√≥ximo
    
    ![Untitled](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/Untitled.png)
    

![IMG_20220802_150530671~2.jpg](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/IMG_20220802_1505306712.jpg)

## Representa√ß√£o dos n√≥s

**Struct** ‚Üí vai ser esse n√≥ com dois dados diferentes

```c
typedef struct no {
	int dado;
	struct no *prox;
} no;

// => typedef int batatafrita; -> batatagrita vai funcionar igual int com o typedef
```

‚áí Para utilizar √© poss√≠vel:

no lista;

**no *lista**

## Opera√ß√µes

### 1) Cria√ß√£o:

le ‚Üí NULL (lista encadeada vazia)

```c
no *cria( ) {
	no *le = NULL;
	return le;
}
```

### 2) Inser√ß√£o

passos:

1 - Crio um novo

2 - Fa√ßo com que o novo aponte para o que o p apontava

3 - Fa√ßo com que p (anterior) aponte para o novo

```c
// Forma padr√£o de fazer

void insert (no p, int x){
	no novo; 
	novo.dado=x;
	novo.prox=p.prox;	
	p.prox=&novo;

// Problema:
//  a) Ta passando por valor
//  b) Variavel construida e destruida no escopo, novo √© excluido da mem√≥ria no final

}

//
void insert (no*p, int x){
	no *novo /*a*/ = malloc(sizeof(no)); /*b*/
	novo -> dado = x;
	novo -> prox = p -> prox; 
	p -> prox = novo;	

**Complexidade O(n)**

// Corre√ß√£o 
//  a) Passando por refer√™ncia agr
//  b) malloc para a variavel permanecer no final e s√≥ √© apagada da mem√≥ria com 
//     o free(verificar se √© free o nome msm)
}
. -> 
```

(foto)

![Untitled](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/Untitled%201.png)

![Untitled](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/Untitled%202.png)

![Untitled](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/Untitled%203.png)

![Untitled](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/Untitled%204.png)

OBS: O operador ‚Üí Acessa o campo de uma struct indiferente (por ponteiro)

### E se quisermos inserir no in√≠cio?

Jeito errado:

![Untitled](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/Untitled%205.png)

le n√£o possui campo prox

Jeito certo:

```c
**(*) Lista encadeada com no cabe√ßa**

if (p==le){
	void insert (no *le, int x){
		no *novo /*a*/ = malloc(sizeof(no)); /*b*/
		novo -> dado = x;
		novo -> prox = le;
		le = novo;
	}
}

```

Representa√ß√£o com no cabe√ßa

![Untitled](Lista%20encadeada%200d22d589205643e7b88d90650dd5d5db/Untitled%206.png)

---

04/08